var documenterSearchIndex = {"docs":
[{"location":"contrib/#Development","page":"-","title":"Development","text":"","category":"section"},{"location":"contrib/#Standard-tests","page":"-","title":"Standard tests","text":"","category":"section"},{"location":"contrib/","page":"-","title":"-","text":"There is a standard test suite called DecTests. The test suite is provided in a custom format. We have a script scripts/dectest.jl for translating test cases from the custom format to common Julia tests. The script should be called like this:","category":"page"},{"location":"contrib/","page":"-","title":"-","text":"julia scripts/dectest.jl <testset name> <dectest path> <output path>","category":"page"},{"location":"contrib/","page":"-","title":"-","text":"For example: julia scripts/dectest.jl Plus dectests/plus.decTest test/dectests/test_plus.jl. We put these test files into the test/dectests subdirectory.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\nusing Decimals\nend","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is a Julia implementation of arbitrary precision decimal floating point arithmetic, where numbers x in mathbbR are represented using the Decimal type as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x = (-1)^s cdot c cdot 10^q","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where s in 0 1 is the signbit, c in mathbbN is the coefficient, and q in mathbbZ is the exponent.","category":"page"},{"location":"#Construction","page":"Introduction","title":"Construction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Decimal object can be created directly, or by conversion from a number, or by parsing from a string:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Decimal(0, 5, -1) # (-1)^0 * 5 * 10^-1\n0.5\n\njulia> Decimal(0.5)\n0.5\n\njulia> Decimal(5E-1)\n0.5\n\njulia> parse(Decimal, \"0.5\")\n0.5\n\njulia> parse(Decimal, \"5E-1\")\n0.5","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Alternatively, a Decimal can be parsed from a string literal via the @dec_str macro, which also supports the thousands separator _:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> dec\"1_000.000_000_1\"\n1000.0000001","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The thousands separator is not supported by the parse function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> parse(Decimal, \"1_000\")\nERROR: ArgumentError: Invalid decimal: 1_000","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Conversion from numbers is exact\nThe constructor Decimal(::Real) converts the given number to a Decimal exactly. The consequence is that Decimal(x) is not generally equal to parse(Decimal, string(x)). For example,julia> Decimal(0.1)\n0.1000000000000000055511151231257827021181583404541015625\n\njulia> parse(Decimal, \"0.1\")\n0.1\n\njulia> dec\"0.1\" # Alternative to parse\n0.1\n\njulia> big(0.1) # Exact value of 0.1 represented by a binary floating-point number\n0.1000000000000000055511151231257827021181583404541015625\n\njulia> string(0.1) # The string representation of 0.1 is deceiving\n\"0.1\"","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"DocTestSetup = quote\nusing Decimals\nusing Decimals: @with_context\nend","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Users can parametrize the decimal arithmetic by setting Decimals.Context using the Decimals.with_context function or the Decimals.@with_context macro. Operations affected by context are denoted by the badge (Image: Affected by context).","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Decimals.Context\nDecimals.with_context\nDecimals.@with_context","category":"page"},{"location":"operations/#Decimals.Context","page":"Operations","title":"Decimals.Context","text":"Context\n\nUser-selectable parametrization of the decimal arithmetics. The parameters are:\n\nParameter Description\nprecision::Int Maximum number of significand digits (default: 28)\nrounding::RoundingMode Rounding mode to be used when necessary (default: RoundNearest)\nEmax::Int Maximum adjusted exponent (default: 999999)\nEmin::Int Minimum adjusted exponent (default: -999999)\n\nThe parameters can be set via the (unexported) function with_context or macro @with_context:\n\njulia> Decimals.with_context(precision=1) do\n           +dec\"0.1234\"\n       end\n0.1\n\njulia> Decimals.@with_context (precision=1,) +dec\"0.1234\"\n0.1\n\n\n\n\n\n","category":"type"},{"location":"operations/#Decimals.with_context","page":"Operations","title":"Decimals.with_context","text":"with_context(f; kwargs...)\n\nRun f with Context parametrized by kwargs.\n\nExamples\n\njulia> Decimals.with_context(precision=42) do\n    precision(Decimal)\nend\n42\n\nSee also @with_context.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Decimals.@with_context","page":"Operations","title":"Decimals.@with_context","text":"@with_context params expr\n\nRun expr with Context parametrized by a named tuple params.\n\nExamples\n\njulia> Decimals.@with_context (precision=42, ) precision(Decimal)\n42\n\nSee also with_context.\n\n\n\n\n\n","category":"macro"},{"location":"operations/#Arithmetic-operations","page":"Operations","title":"Arithmetic operations","text":"","category":"section"},{"location":"operations/#Unary-plus,-minus","page":"Operations","title":"Unary plus, minus","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"(Image: Affected by context)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The unary plus, +x, and unary minus, -x, is equivalent to 0 + x and 0 - x, respectively.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"1.1\"\n1.1\n\njulia> +x\n1.1\n\njulia> -x\n-1.1","category":"page"},{"location":"operations/#Addition,-subtraction","page":"Operations","title":"Addition, subtraction","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"(Image: Affected by context)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Addition and subtraction are implemented via the binary operators + and y.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"1.1\"\n1.1\n\njulia> y = dec\"2.2\"\n2.2\n\njulia> x + y\n3.3\n\njulia> x - y\n-1.1","category":"page"},{"location":"operations/#Multiplication,-division","page":"Operations","title":"Multiplication, division","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"(Image: Affected by context)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Multiplication and division are implemented via the binary operators * and /.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Division by zero throws DivisionByZeroError unless the dividend is also zero, in which case UndefinedDivisionError is thrown.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"2\"\n2\n\njulia> y = dec\"3\"\n3\n\njulia> x * y\n6\n\njulia> x / y\n0.6666666666666666666666666667\n\njulia> x / dec\"0\"\nERROR: DivisionByZeroError()\n\njulia> dec\"0\" / dec\"0\"\nERROR: UndefinedDivisionError()","category":"page"},{"location":"operations/#Absolute-value","page":"Operations","title":"Absolute value","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"(Image: Affected by context)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Absolute value is implemented via the Base.abs function.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> abs(dec\"1\")\n1\n\njulia> abs(dec\"-1\")\n1","category":"page"},{"location":"operations/#Minimum,-maximum","page":"Operations","title":"Minimum, maximum","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"(Image: Affected by context)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Selecting the minimum and maximum of two Decimals is implemented via the Base.min and Base.max functions.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"0.123\"\n0.123\n\njulia> y = dec\"4.567\"\n4.567\n\njulia> min(x, y)\n0.123\n\njulia> max(x, y)\n4.567","category":"page"},{"location":"operations/#Comparison-operations","page":"Operations","title":"Comparison operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The basic comparison operation is implemented via Base.cmp, which compares x and y and returns -1, 0, or +1 if x is less than, equal to, or greater than y.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"0.123\"\n0.123\n\njulia> y = dec\"4.567\"\n4.567\n\njulia> cmp(x, y)\n-1\n\njulia> cmp(y, x)\n1","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The binary operators ==, <, and <= are also implemented.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"0.123\"\n0.123\n\njulia> y = dec\"4.567\"\n4.567\n\njulia> x == y\nfalse\n\njulia> x < y\ntrue\n\njulia> x > y\nfalse\n\njulia> x <= y\ntrue\n\njulia> x >= y\nfalse","category":"page"},{"location":"operations/#Miscellaneous","page":"Operations","title":"Miscellaneous","text":"","category":"section"},{"location":"operations/#Hashing","page":"Operations","title":"Hashing","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"Hashing of Decimals is supported via the Base.hash function. It holds for the output hash code that x == y implies hash(x) == hash(y), and this is true even if one of the operands is not a Decimal.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = Decimal(0, 2125, -3)\n2.125\n\njulia> y = Decimal(0, 212500, -5)\n2.12500\n\njulia> hash(x) == hash(y)\ntrue\n\njulia> hash(x) == hash(2.125)\ntrue","category":"page"},{"location":"operations/#Rounding","page":"Operations","title":"Rounding","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The standard interface for rounding floating-point numbers is supported:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"julia> x = dec\"123.45678\"\n123.45678\n\njulia> round(x) # Round to the nearest integer\n123\n\njulia> round(Int, x) # Round to the nearest integer and convert to Int\n123\n\njulia> round(x, RoundUp) # Round using a particular rounding mode\n124\n\njulia> round(x, digits=4) # Round to four decimal places\n123.4568\n\njulia> round(x, sigdigits=4) # Round to four significant digits\n123.5","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Our test suite covers six rounding modes that are specified by the Decimal arithmetic specification.  The rounding modes are","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"RoundNearest (round-half-even in the specification),\nRoundNearestTiesAway (round-half-up),\nRoundUp (round-ceiling),\nRoundDown (round-floor),\nRoundFromZero (round-up),\nRoundToZero (round-down).","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"The default mode is RoundNearest.","category":"page"},{"location":"operations/#Normalization","page":"Operations","title":"Normalization","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"(Image: Affected by context)","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Normalization of a Decimal removes all trailing zeros of the coefficient c while adjusting the exponent q so that the Decimal remains the same (up to the precision given by context). The operation is semantically equivalent to unary plus.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"normalize","category":"page"},{"location":"operations/#Decimals.normalize","page":"Operations","title":"Decimals.normalize","text":"normalize(x::Decimal)\n\nReturn an equal number reduced to its simplest form with all trailing zeros in the coefficient removed.\n\nExamples\n\njulia> x = dec\"1.2000\"\n1.2000\n\njulia> x.c # Coefficient of `x`\n12000\n\njulia> y = normalize(dec\"1.2000\")\n1.2\n\njulia> y.c # Coefficient of `y`\n12\n\njulia> x == y\ntrue\n\n\n\n\n\n","category":"function"},{"location":"operations/#Exception-types","page":"Operations","title":"Exception types","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"DivisionByZeroError\nUndefinedDivisionError","category":"page"},{"location":"operations/#Decimals.DivisionByZeroError","page":"Operations","title":"Decimals.DivisionByZeroError","text":"DivisionByZeroError\n\nDivision was attempted with a denominator value of 0.\n\n\n\n\n\n","category":"type"},{"location":"operations/#Decimals.UndefinedDivisionError","page":"Operations","title":"Decimals.UndefinedDivisionError","text":"UndefinedDivisionError\n\nDivision was attempted with both numerator and denominator value of 0.\n\n\n\n\n\n","category":"type"}]
}
